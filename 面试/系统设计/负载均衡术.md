为了提高后端的效率, 往往需要对机器进行拓展. 垂直拓展指增加单台实例的性能.而水平拓展指的是使用一个集群来代替单一的机器 通过增加机器的数量 使得这个集群处理能力线性提升
一般我们都采用水平拓展, 
1. 可以通过多台廉价的实例来达到一台性能强大的服务器的处理效果,经济上是划算的
2. 通过集群 部分节点崩溃整个系统任然可用 即达到高可用的效果

一个问题是, 如果后端是多态实例, 请求打到API网关后 应该如何确定这个请求该发往哪一台实例?  这就是负载均衡的问题
负载均衡要解决的问题, 除了请求该发往何方 还有

1. 如何使得请求发散得尽量均匀 而不至于使得某台实例"过热"而造成瓶颈  
2. 如果有新节点加入或离开集群, 负载均衡策略仍然起作用 影响尽量小



## 常见的负载均衡策略

常见的分区规则可以分为以下两种:

| 分布方式 | 特点                                                         | 典型产品                               |
| -------- | ------------------------------------------------------------ | -------------------------------------- |
| 哈希分区 | 数据分散度高、键值分布无业务无关、无法顺序访问、支持批量操作。 | 一致性哈希：Mecache、Redis Cluster ... |
| 顺序分区 | 数据分散度易倾斜、键值业务相关、可以顺序访问、支持批量操作。 | BigTable、HBase                        |

简而言之, 顺序分区容易造成局部过热的情况, 但是支持顺序访问 一般如HBase这类Nosql数据库使用; hash分区分散程度更高, 但是不能顺序访问 Redis Cluster是典型代表



### 哈希分区

因为Redis Cluster采用的哈希分区，所以我们看一下常见的哈希分区有哪几种。

#### 节点取余分区

比如100个数据，对每个数据进行hash运算之后，再于节点数进行取余运算，根据余数保存在不同节点上。

![img](https://segmentfault.com/img/remote/1460000038771819)

缺点就是：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。

![img](https://segmentfault.com/img/remote/1460000038771832)

#### 一致性哈希分区

为系统中每个节点分配一个token，范围一般在0~2的32次方，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点，如下图所示

![img](https://segmentfault.com/img/remote/1460000038771816)

这种方式相比节点取余最大的好处在于**加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响**。

但一致性哈希也存在一些问题：

- 加减节点会造成哈希环中部分数据无法命中（例如一个key增减节点前映射到第n2个节点，因此它的数据是保存在第n2个节点上的；当我们增加一个节点后被映射到n5节点上了，此时我们去n5节点上去找这个key对应的值是找不到的，见下图），需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。

    ![img](https://segmentfault.com/img/remote/1460000038771833)

- 当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式**不适合少量数据节点**的分布式方案。

- 普通的一致性哈希分区在增减节点时需要**增加一倍或减去一半节点**才能保证数据和负载的均衡。

#### 虚拟槽分区

Redis Cluster采用的就是虚拟槽分区。槽的范围是0~16383，将16384个槽平均分配给节点，由节点进行管理。

每次将key进行CRC16运算，对16383进行取余，然后去redis对应的槽进行查找。

槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽。
