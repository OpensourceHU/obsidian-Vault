---
title: volatile 与 synchronizd关键字
---



## volatile关键字与synchronized关键字

### volatile引入: 缓存一致性问题

CPU速度太快,为了不让CPU等数据, 在CPU与主存之间还增加了多级缓存,即Cache1　Cache2 Cache3。 即存储器层次结构：

寄存器组 ——  多级缓存  —— 主存  ——  磁盘

这套系统在单核CPU上运作良好，但是随着摩尔定律的发展，CPU的运算速度出现了瓶颈，厂家们开始堆核，多核CPU出现。  

**物理内存模型： 即存储器层次结构**

随之而来一个问题：**缓存一致性问题**

CPU在处理数据时，优先从离它近的存储介质里读（先读寄存器，没命中再读一级缓存，又没命中再读二级缓存… 读主存 读磁盘）

这里就存在了一个问题， RAM是所有CPU共享的，但是Cache是CPU独享的， 每次优先从独享的Cache中读数据，读到的数据一致性就无法保证

如何解决呢？  计算机科学家定义了一系列的**缓存一致性协议**，具体实现细节不做探究，但是可以肯定的是和数据一致性操作有关的，必然涉及到“等待唤醒”等操作。

但是CPU是速度极快的，丝毫的等待都是不可忍受的，因此又做了一系列优化，即将数据的同步改为异步， 将指令重排序：一个CPU在读写共享变量时首先发现其它CPU正在修改，则做一个标记，先去做别的指令  

*这样又出现了一个新的问题，如何保证指令重排序后与原先的顺序执行的结果一致?  这里又是一系列协议… 不在讨论范围内了*

重排序大概由一下三种组成

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;
- 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。

### volatile的底层

volatile关键字屏蔽了指令重排,并使修饰的变量强制刷新回内存,其它CPU每次读取volatile变量则从内存读取(总线嗅探)  这样就保证了volatile修饰的变量在每个线程中读到的都是最新的。

### synchronized与锁升级机制

#### Monitor && Mutex Lock && Test and Set

synchronized一开始并没有锁升级机制,JDK1.6之前只有有锁和无锁两种状态，锁是基于monitor实现的(也就是重量级锁)，**monitor又是通过操作系统中的Mutex Lock（互斥锁），Mutex Lock的实现是基于指令集中提供了Test and Set 这样的原子操作**来实现的，**每次需要操作系统从用户态切换到核心态**，这样的开销是非常大的，因此被称为重量级锁。  

monitor可以译作监视器

monitor是一种是基于等待唤醒实现的锁，当一个线程进入monitor有三个时期（如下图）；

1. 进入monitor，此时是被分配在entry set 中，等待lock的拥有者释放锁；

2. 当线程获得lock就会成为lock的拥有者（仅有一个线程可以拥有），此时处于 the owner 区域；

3. 当释放lock就会进入wait set ，但是处于wait set 中的线程还是有机会获得lock的拥有权。

#### Mark Word

每一次new一个对象，则会在堆中开辟一块空间，这块空间又可以细分为三块：

对象头（Mark word）、实例数据（Instance Data）、对齐填充（Pending）

其中实例数据存放成员变量等内容，对齐填充主要用于对齐（方便加载）

而Mark Word存放了一些该实例的信息，由于JVM中万事万物皆对象 对象很多，因此Markword设计成**联合体**的形式，以节省空间

Mark Word中会存放这些信息： **哈希码、GC分代的年龄、锁相关的信息**

Java类加载后会在堆中创建一个对象,每个对象有一个对象头（Mark word）,最后两个为锁标志位  所以**每次锁的是一个实例**
**Java锁升级机制**

#### 偏向锁：

当只有一个线程会获取该对象时，这个时候没有必要使用锁，虽然叫偏向锁，其实用了无锁的设计思想： 只有一个线程需要这个锁，那么就记录下这个线程的信息，当需要时直接就把自己交出去

#### 轻量级锁：

轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。

所谓自旋，其实就是让CPU忙等，如果争抢的资源可以很快被释放，那么自旋的开销就比较小，小于用户态和内核态切换的开销，所以优先设置轻量级锁

#### 重量级锁

轻量级锁的忙等是有限度的（有个计数器记录自旋次数，**默认允许循环10次**，可以通过虚拟机参数更改）。如果锁竞争情况严重（有**三个以上的**），某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。

重量就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资源。

## 什么是乐观锁，什么是CAS？

**乐观锁**：说是乐观锁，其实是一种无锁的思想，由于mutex lock需要系统调用开销过大，所以想绕开锁也实现线程同步。  

与乐观锁相对的是悲观锁，这里的乐观与悲观是以设计思路来区分的，悲观锁的设计者悲观的地认为：线程在访问共享资源时一定会被其它线程干扰，所以为了独占资源 应该先将资源上锁；   乐观锁的设计者乐观地认为：线程在操作共享资源时不会被其它线程干扰，不管三七二十一，我自己先操作再说。 如果有其它线程在我访问共享资源时干扰我，我再作处理（比如MySQL的MVCC基于版本号来控制， 又比如Java的轻量级锁基于CAS来实现乐观锁）

**这里的乐观锁与悲观锁不是说具体的实现方式，而是两种锁的设计思想**

乐观锁具体怎么实现？ — CAS： 
当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值（old_value），基于 old_value进行计算，得到新值new_value，再用预期old_value和内存中当前的共享变量值进行比较，**「如果相同就认为其他线程没有进行修改」**，而将新值new_value写入内存。 这种比较并交换的操作，英文就是Compare And Swap-CAS。

这里涉及到一个问题，就是**比较共享变量当前值与old_value，若符合预期（两者相等，表明在计算new_value期间没有新的线程修改这个值）则更新，若不符合预期，则自旋等待。**   这个比较并交换（CAS）操作必须是**原子**的。 如何实现原子呢？总不能加锁吧，本来就是为了实现无锁编程。所幸各个CPU厂商已经在指令集层面实现了这个原子操作，比如X86下为`CMPXCHG`（compare and exchange）

CAS具体在Java的哪些地方 有体现呢：

1. 轻量级锁自旋
2. 并发包的实现比如AtomicInteger与AtomicLong的实现

