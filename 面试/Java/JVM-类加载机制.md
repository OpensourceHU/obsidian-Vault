#类加载机制 #JVM
# 类加载机制

Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。
这一部分 可以看看 《深入理解Java虚拟机》 周志明 的 第七章

## 类的声明周期

类从被加载到虚拟机内存中开始，到卸载出内存为止，**它的整个生命周期包括：加载，验证，准备，解析，初始化,使用,卸载**这7个阶段.

**类加载的三个过程: 加载、连接、初始化**

**其中连接分为： 验证、准备、解析3个部分**

## 类加载

### 加载

简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。

这里有两个重点：

- **字节码来源**。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译
- **类加载器**。一般包括**启动类加载器**，**扩展类加载器**，**应用类加载器**，以及用户的**自定义类加载器**。

类加载是整个类中唯二程序员可以控制的过程，可以编写自己的类加载器进行加载。这里的字节码只要符合JVM规范即可，无关来源。

一般来讲，是通过全限定类名来进行类加载，但是也可以从网络、从JAR包进行加载。

#### 类加载时——双亲委派机制

当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。 只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。

![[1158910-20210223225901148-183547131.png]]

三大加载器由高到低分别为：启动类加载器、拓展类加载器、应用类加载器 

一个类被加载时先递归地查询父类加载器能否加载，是否加载过 若能则交由父类加载加载，若不能则自己加载

这样做的好处是避免核心类被篡改，**一个类被是由类完全限定名与加载器共同确定的**

自己写的类总是被应用类加载器加载，假如已经被加载过了，就不会再加载了，如果非要加载，就会报错
![[image-20220510174139562.png]]

如果再自己写一个类加载器去加载，会发现lang包下的代码是被保护的

### 连接

#### 验证

检查是否符合class文件的规范,是否有危险行为

会有四大步骤，可以选择关掉部分

- 文件格式验证: 验证字节流是否符合Class文件格式的规范；例如: 是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。

- 元数据验证：对字节码描述的信息进行语义分析(注意: 对比`javac`编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了`java.lang.Object`之外。

- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

- 符号引用验证：确保解析动作能正确执行。

#### 准备

静态变量分配内存并赋零值

#### 解析

符号引用转化为直接引用,可能在初始化前,也可能在初始化后(动态解析)

符号引用就是一组符号来描述目标，可以是任何字面量。

直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

初始化也是程序员可控的，类中的初始化语句可以由程序员编写。  所有static的变量与代码块会被抽出，组成一个init<>()方法， 初始化时会触发这个方法

初始化的时机

1. new对象的时候
2. 调用静态的方法、属性的时候
3. 用反射获取该类信息的时候，发现没有初始化则会先初始化再获取

初始化的原则： 父类先初始化，父类初始化后子类再初始化。


