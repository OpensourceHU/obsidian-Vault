ref: [[五种IO模型]]
这两个概念经常有人弄混, 甚至很多博客瞎写, csdn上以讹传讹
同步/异步的关注点在于:  **这次调用是否影响主进程, 换言之 IO是否独立于主线程的**
阻塞/非阻塞的关注点在于:  **结果是否立即返回 , 换言之 进程等待资源时的状态**

### 异步同步
以CPU与外设之间的信息交互为例
查询传输: CPU询问外设信息是否准备好, 若准备好了,则接通总线进行数据传输, 否则CPU等待
DMA: 数据准备好后 外设申请控制总线 总线仲裁后, 外设直接向CPU传输数据
这里的查询传输, CPU在发起后 主进程受到了影响, 是否拿得到数据影响CPU进一步的操作, 所以是同步的
而DMA这次数据传输 , IO操作根本不影响当前进程的下一步操作, 所以是异步的
软件编程中, 典型的异步编程模型比如Nodejs, ajax收发请求


### 阻塞非阻塞
阻塞在进程描述的语境里是表示这样一种状态: 当前进程占用着CPU的时间片 但是等待的资源没有就位 所以CPU空转
所以当阻塞在描述IO的时候, 也是表明当前IO调用 在等待结果时的状态
Future类就提供了这样一种做法: 立即返回给你一个结果, 当你需要这个结果的时候, 可以通过get来查看  这样就不用等待了,这就是非阻塞的做法
阻塞的做法, 比如C语言要一个socket 链接, recevFrom()要返回两个socket fd, 在这两个fd拿到之前, 用户进程必须等待OS 什么都不能干, 则阻塞住了
