## 集群
关于Redis的Hash槽分区可以参考[[../系统设计/负载均衡术#虚拟槽分区]]
Redis集群采用槽指派的方式进行集群构建; 
将key 进行一个CRC16运算 得到的值与hash槽数量16384进行取模得到hash槽的下标位置  进而确定这个key是存放在哪个节点上的;

每个节点维护三个数据结构
ClusterNode: 每个节点的信息
ClusterLink: 与其它节点的连接信息
ClusterState: 集群信息(当前节点视角下)
![[assets/image-20230320110847450.png]]
而每个clusterNode中的slot则是一个位图, 记录当前节点负责哪些槽
节点间通过`cluster meet`指令相连接, 并交换信息;


### 故障转移
clusterNode中 flag标记当前节点是否为主节点
- 主节点负责维护槽
- 从节点负责备份主节点

1. 故障检测
所有主节点间相互监听ping信息, 如果发现某台主节点没有pong, 则在自己的节点信息clusterNode中将这台崩溃的主节点标记为PFAIL (probably Fail), 然后主节点间相互传递信息, 有半数以上的节点认为其PFAIL 则标记为FAIL

2. 故障转移
从节点, 则监听主节点的消息  当主节点下线后, 参与选举并晋升为主节点
参与选举可以参考 [[../Raft协议#节点选举问题]] 唯一的区别是
这次参与选举的是从节点, 而投票的是其它没有crash的主节点

## 主从复制
需要注意的是, 当在进行同步的时候  会进行psync(增量同步)[psync文档](https://redis.io/commands/psync/)
主从双方维护一个offset变量 , 相当于对每个命令的一个自增ID 通过对比这个偏移量可以判断是进行增量同步还是全量同步(redis的策略是优先进行增量同步)
当同步完成后, 从节点会继续监听主节点发来的AOF消息

