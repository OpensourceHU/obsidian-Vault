读未提交   
读已提交  解决脏读问题
可重复读(InnoDB默认) 解决不可重复读,InnoDB用间隙锁解决了幻读问题
串行化

**读未提交**: 

读到了其他事务还没有提交的数据 这当然是业务所不允许的

**读已提交**: 

看上去是没问题的, 但是部分情况下 比如A事务查看账户并扣款 B事务直接在A查看账户后把款扣完了, 这个时候账户里是没钱的 A事务再扣款,钱就变成负数了

解决的方法是:  在读取的时候 禁止其它事务进行update操作, 相当与加了行X锁

**可重复读**:

解决读已提交中不可重复读的问题,  在事务的任何阶段, 除非事务自己对表进行了修改 否则看到的表都是同一个视图  针对update,如上所述使用行X锁即可  针对insert,需要使用间隙锁
参考: [MySQL :: MySQL 8.0 Reference Manual :: 15.7.4 Phantom Rows](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)

**间隙锁**

>`InnoDB` performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the index records it encounters. Thus, the row-level locks are actually index-record locks.

InnoDB的行锁其实锁住的并不是行(如果锁行的话效率太低了) 而是对应行上的索引(聚簇索引)    只要索引这个级别加上了X锁S锁, 相当于这条索引下辖的所有记录都上锁了, 很容易想明白, 因为确定数据前要先走到索引再走到数据
这样容易产生一个问题
比如有数据:
{97,98,99,102,103...200} 它的索引建在{97,120,150,170}上
我们
`SELECT * FROM child WHERE id > 100 FOR UPDATE;`
这样锁住了哪些索引?  120 150 170 对应到数据 锁住了120~200的数据
这个时候insert一条数据 101 这101是没被锁住的,所以可以正常的插入; 但是它不该被插入 因为我们想要的 是锁住>100范围内的所有数据
所以为了锁住所有数据  我们必须要在 97-120这个间隙上 也加上锁
即每次加锁的范围, 不光包含索引本身,还有它前后的一个间隙 这样来防止幻读问题
[[MySQL锁事]]
